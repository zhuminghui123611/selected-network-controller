{"version":3,"file":"SelectedNetworkController.cjs","sourceRoot":"","sources":["../src/SelectedNetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  BlockTrackerProxy,\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetSelectedNetworkClientAction,\n  NetworkControllerGetStateAction,\n  NetworkControllerStateChangeEvent,\n  ProviderProxy,\n} from '@metamask/network-controller';\nimport type {\n  PermissionControllerStateChange,\n  GetSubjects as PermissionControllerGetSubjectsAction,\n  HasPermissions as PermissionControllerHasPermissions,\n} from '@metamask/permission-controller';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport type { Patch } from 'immer';\n\nexport const controllerName = 'SelectedNetworkController';\n\nconst stateMetadata = {\n  domains: {\n    includeInStateLogs: true,\n    persist: true,\n    anonymous: false,\n    usedInUi: true,\n  },\n};\n\nconst getDefaultState = () => ({ domains: {} });\n\nexport type Domain = string;\n\nexport const METAMASK_DOMAIN = 'metamask' as const;\n\nexport const SelectedNetworkControllerActionTypes = {\n  getState: `${controllerName}:getState` as const,\n  getNetworkClientIdForDomain:\n    `${controllerName}:getNetworkClientIdForDomain` as const,\n  setNetworkClientIdForDomain:\n    `${controllerName}:setNetworkClientIdForDomain` as const,\n};\n\nexport const SelectedNetworkControllerEventTypes = {\n  stateChange: `${controllerName}:stateChange` as const,\n};\n\nexport type SelectedNetworkControllerState = {\n  domains: Record<Domain, NetworkClientId>;\n};\n\nexport type SelectedNetworkControllerStateChangeEvent = {\n  type: typeof SelectedNetworkControllerEventTypes.stateChange;\n  payload: [SelectedNetworkControllerState, Patch[]];\n};\n\nexport type SelectedNetworkControllerGetSelectedNetworkStateAction = {\n  type: typeof SelectedNetworkControllerActionTypes.getState;\n  handler: () => SelectedNetworkControllerState;\n};\n\nexport type SelectedNetworkControllerGetNetworkClientIdForDomainAction = {\n  type: typeof SelectedNetworkControllerActionTypes.getNetworkClientIdForDomain;\n  handler: SelectedNetworkController['getNetworkClientIdForDomain'];\n};\n\nexport type SelectedNetworkControllerSetNetworkClientIdForDomainAction = {\n  type: typeof SelectedNetworkControllerActionTypes.setNetworkClientIdForDomain;\n  handler: SelectedNetworkController['setNetworkClientIdForDomain'];\n};\n\nexport type SelectedNetworkControllerActions =\n  | SelectedNetworkControllerGetSelectedNetworkStateAction\n  | SelectedNetworkControllerGetNetworkClientIdForDomainAction\n  | SelectedNetworkControllerSetNetworkClientIdForDomainAction;\n\nexport type AllowedActions =\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetStateAction\n  | PermissionControllerHasPermissions\n  | PermissionControllerGetSubjectsAction;\n\nexport type SelectedNetworkControllerEvents =\n  SelectedNetworkControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerStateChangeEvent\n  | PermissionControllerStateChange;\n\nexport type SelectedNetworkControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  SelectedNetworkControllerActions | AllowedActions,\n  SelectedNetworkControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport type SelectedNetworkControllerOptions = {\n  state?: SelectedNetworkControllerState;\n  messenger: SelectedNetworkControllerMessenger;\n  domainProxyMap: Map<Domain, NetworkProxy>;\n};\n\nexport type NetworkProxy = {\n  provider: ProviderProxy;\n  blockTracker: BlockTrackerProxy;\n};\n\n/**\n * Controller for getting and setting the network for a particular domain.\n */\nexport class SelectedNetworkController extends BaseController<\n  typeof controllerName,\n  SelectedNetworkControllerState,\n  SelectedNetworkControllerMessenger\n> {\n  readonly #domainProxyMap: Map<Domain, NetworkProxy>;\n\n  /**\n   * Construct a SelectedNetworkController controller.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The restricted messenger for the EncryptionPublicKey controller.\n   * @param options.state - The controllers initial state.\n   * @param options.domainProxyMap - A map for storing domain-specific proxies that are held in memory only during use.\n   */\n  constructor({\n    messenger,\n    state = getDefaultState(),\n    domainProxyMap,\n  }: SelectedNetworkControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state,\n    });\n    this.#domainProxyMap = domainProxyMap;\n    this.#registerMessageHandlers();\n\n    // this is fetching all the dapp permissions from the PermissionsController and looking for any domains that are not in domains state in this controller. Then we take any missing domains and add them to state here, setting it with the globally selected networkClientId (fetched from the NetworkController)\n    this.messagingSystem\n      .call('PermissionController:getSubjectNames')\n      .filter((domain) => this.state.domains[domain] === undefined)\n      .forEach((domain) =>\n        this.setNetworkClientIdForDomain(\n          domain,\n          this.messagingSystem.call('NetworkController:getState')\n            .selectedNetworkClientId,\n        ),\n      );\n\n    this.messagingSystem.subscribe(\n      'PermissionController:stateChange',\n      (_, patches) => {\n        patches.forEach(({ op, path }) => {\n          const isChangingSubject =\n            path[0] === 'subjects' && path[1] !== undefined;\n          if (isChangingSubject && typeof path[1] === 'string') {\n            const domain = path[1];\n            if (op === 'add' && this.state.domains[domain] === undefined) {\n              this.setNetworkClientIdForDomain(\n                domain,\n                this.messagingSystem.call('NetworkController:getState')\n                  .selectedNetworkClientId,\n              );\n            } else if (\n              op === 'remove' &&\n              this.state.domains[domain] !== undefined\n            ) {\n              this.#unsetNetworkClientIdForDomain(domain);\n            }\n          }\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:stateChange',\n      (\n        { selectedNetworkClientId, networkConfigurationsByChainId },\n        patches,\n      ) => {\n        const patch = patches.find(\n          ({ op, path }) =>\n            (op === 'replace' || op === 'remove') &&\n            path[0] === 'networkConfigurationsByChainId',\n        );\n\n        if (patch) {\n          const networkClientIdToChainId = Object.values(\n            networkConfigurationsByChainId,\n          ).reduce(\n            (acc, network) => {\n              network.rpcEndpoints.forEach(\n                ({ networkClientId }) =>\n                  (acc[networkClientId] = network.chainId),\n              );\n              return acc;\n            },\n            {} as Record<string, Hex>,\n          );\n\n          Object.entries(this.state.domains).forEach(\n            ([domain, networkClientIdForDomain]) => {\n              const chainIdForDomain =\n                networkClientIdToChainId[networkClientIdForDomain];\n\n              if (patch.op === 'remove' && !chainIdForDomain) {\n                // If the network was removed, fall back to the globally selected network\n                this.setNetworkClientIdForDomain(\n                  domain,\n                  selectedNetworkClientId,\n                );\n              } else if (patch.op === 'replace') {\n                // If the network was updated, redirect to the network's default endpoint\n\n                const updatedChainId = patch.path[1] as Hex;\n                if (!chainIdForDomain || chainIdForDomain === updatedChainId) {\n                  const network =\n                    networkConfigurationsByChainId[updatedChainId];\n\n                  const { networkClientId: defaultNetworkClientId } =\n                    network.rpcEndpoints[network.defaultRpcEndpointIndex];\n\n                  if (networkClientIdForDomain !== defaultNetworkClientId) {\n                    this.setNetworkClientIdForDomain(\n                      domain,\n                      defaultNetworkClientId,\n                    );\n                  }\n                }\n              }\n            },\n          );\n        }\n      },\n    );\n  }\n\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      SelectedNetworkControllerActionTypes.getNetworkClientIdForDomain,\n      this.getNetworkClientIdForDomain.bind(this),\n    );\n    this.messagingSystem.registerActionHandler(\n      SelectedNetworkControllerActionTypes.setNetworkClientIdForDomain,\n      this.setNetworkClientIdForDomain.bind(this),\n    );\n  }\n\n  #setNetworkClientIdForDomain(\n    domain: Domain,\n    networkClientId: NetworkClientId,\n  ) {\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n\n    // This needs to happen before getProviderAndBlockTracker,\n    // otherwise we may be referencing a network client ID that no longer exists.\n    this.update((state) => {\n      state.domains[domain] = networkClientId;\n    });\n\n    const networkProxy = this.getProviderAndBlockTracker(domain);\n    networkProxy.provider.setTarget(networkClient.provider);\n    networkProxy.blockTracker.setTarget(networkClient.blockTracker);\n  }\n\n  /**\n   * This method is used when a domain is removed from the PermissionsController.\n   * It will remove re-point the network proxy to the globally selected network in the domainProxyMap or, if no globally selected network client is available, delete the proxy.\n   *\n   * @param domain - The domain for which to unset the network client ID.\n   */\n  #unsetNetworkClientIdForDomain(domain: Domain) {\n    const globallySelectedNetworkClient = this.messagingSystem.call(\n      'NetworkController:getSelectedNetworkClient',\n    );\n    const networkProxy = this.#domainProxyMap.get(domain);\n    if (networkProxy && globallySelectedNetworkClient) {\n      networkProxy.provider.setTarget(globallySelectedNetworkClient.provider);\n      networkProxy.blockTracker.setTarget(\n        globallySelectedNetworkClient.blockTracker,\n      );\n    } else if (networkProxy) {\n      this.#domainProxyMap.delete(domain);\n    }\n    this.update((state) => {\n      delete state.domains[domain];\n    });\n  }\n\n  #domainHasPermissions(domain: Domain): boolean {\n    return this.messagingSystem.call(\n      'PermissionController:hasPermissions',\n      domain,\n    );\n  }\n\n  setNetworkClientIdForDomain(\n    domain: Domain,\n    networkClientId: NetworkClientId,\n  ) {\n    if (domain === METAMASK_DOMAIN) {\n      throw new Error(\n        `NetworkClientId for domain \"${METAMASK_DOMAIN}\" cannot be set on the SelectedNetworkController`,\n      );\n    }\n\n    if (!this.#domainHasPermissions(domain)) {\n      throw new Error(\n        'NetworkClientId for domain cannot be called with a domain that has not yet been granted permissions',\n      );\n    }\n\n    this.#setNetworkClientIdForDomain(domain, networkClientId);\n  }\n\n  getNetworkClientIdForDomain(domain: Domain): NetworkClientId {\n    const { selectedNetworkClientId: metamaskSelectedNetworkClientId } =\n      this.messagingSystem.call('NetworkController:getState');\n\n    return this.state.domains[domain] ?? metamaskSelectedNetworkClientId;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @param domain - the domain for the provider\n   * @returns The proxy and block tracker proxies.\n   */\n  getProviderAndBlockTracker(domain: Domain): NetworkProxy {\n    // If the domain is 'metamask', return the NetworkController's globally selected network client proxy\n    if (domain === METAMASK_DOMAIN) {\n      const networkClient = this.messagingSystem.call(\n        'NetworkController:getSelectedNetworkClient',\n      );\n      if (networkClient === undefined) {\n        throw new Error('Selected network not initialized');\n      }\n      return networkClient;\n    }\n\n    let networkProxy = this.#domainProxyMap.get(domain);\n    if (networkProxy === undefined) {\n      let networkClient;\n      if (this.#domainHasPermissions(domain)) {\n        const networkClientId = this.getNetworkClientIdForDomain(domain);\n        networkClient = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        );\n      } else {\n        networkClient = this.messagingSystem.call(\n          'NetworkController:getSelectedNetworkClient',\n        );\n        if (networkClient === undefined) {\n          throw new Error('Selected network not initialized');\n        }\n      }\n      networkProxy = {\n        provider: createEventEmitterProxy(networkClient.provider),\n        blockTracker: createEventEmitterProxy(networkClient.blockTracker, {\n          eventFilter: 'skipInternal',\n        }),\n      };\n      this.#domainProxyMap.set(domain, networkProxy);\n    }\n    return networkProxy;\n  }\n}\n"]}